untyped

global function ShHoverVehicle_Init
#if SERVER
global function SpawnTridentTest
#endif

#if CLIENT
global function SetupThirdPersonForVehicle
global function TridentBoost_Visuals
#endif

const LERP_IN_FLOAT = 0.5
const TRIDENT_HOVER_HEIGHT = 60

void function ShHoverVehicle_Init()
{
	#if SERVER
		PrecacheModel($"mdl/vehicles_r5/land/msc_suv_partum/veh_land_msc_suv_partum_static.rmdl")
		AddClientCommandCallback( "spawntridentatcrosshair", CC_SpawnTrident )
		RegisterSignal("NewTridentAnim")
		RegisterSignal("StopDriving")
	#endif
}

#if SERVER
bool function CC_SpawnTrident( entity player, array<string> args )
{
	thread SpawnTridentTest(player)
	return true	
}

void function SpawnTridentTest(entity player)
{
    vector origin = GetPlayerCrosshairOrigin( player )
	origin.z -= 25
	vector angles = Vector(0,0,0)

	entity physics = CreateEntity( "prop_physics" )
	physics.SetValueForModelKey( $"mdl/vehicles_r5/land/msc_suv_partum/veh_land_msc_suv_partum_static.rmdl" )
	physics.kv.rendercolor = "255 255 255"
	physics.kv.CollisionGroup = TRACE_COLLISION_GROUP_BLOCK_WEAPONS_AND_PHYSICS
	physics.kv.spawnflags = 4
	physics.kv.fadedist = -1
	physics.kv.physdamagescale = 0.1
	physics.kv.inertiaScale = 1.0
	physics.kv.renderamt = 255
	physics.kv.rendercolor = "255 255 255"
	physics.kv.solid = SOLID_VPHYSICS
	physics.SetOrigin( origin )
	physics.SetAngles( angles )
	DispatchSpawn( physics )

	physics.PhysicsSetDamping(0,0)
	physics.PhysicsSetFriction(0)
	physics.StopPhysics()
	
	physics.SetModel($"mdl/vehicles_r5/land/msc_suv_partum/veh_land_msc_suv_partum_static.rmdl")
	physics.SetValueForModelKey( $"mdl/vehicles_r5/land/msc_suv_partum/veh_land_msc_suv_partum_static.rmdl" )
	physics.Hide()
	
	entity trident = CreateEntity( "prop_dynamic" )
    trident.SetValueForModelKey( $"mdl/vehicle/olympus_hovercraft/olympus_hovercraft_v2.rmdl")
	trident.kv.fadedist = 10000
	trident.kv.renderamt = 255
    trident.SetOrigin(physics.GetOrigin())
    trident.SetAngles(Vector(0,90,90))
	DispatchSpawn( trident )
	trident.SetParent(physics)
	
	trident.e.physicsCar = physics
	
	trident.SetUsable()
	trident.SetUsableByGroup("pilot")
	trident.SetUsePrompts("%use% Drive Trident", "%use% Drive Trident")
	trident.AddUsableValue( USABLE_CUSTOM_HINTS | USABLE_BY_OWNER | USABLE_BY_PILOTS | USABLE_BY_ENEMIES )
	AddCallback_OnUseEntity(trident, OnUseCar)	
}

void function OnUseCar(entity trident, entity user, int input)
{
	if(IsValid(trident.e.driver))
		return

	thread GetPlayerInVehicle(user, trident.e.physicsCar, trident)

}
void function GetPlayerInVehicle( entity player, entity vehicle, entity trident )
{
	if(IsValid(trident.e.driver))
		return

	trident.e.driver = player
	vehicle.SetPhysics(MOVETYPE_VPHYSICS) 
	RemoveCallback_OnUseEntity(trident, OnUseCar)
	trident.RemoveUsableValue(USABLE_CUSTOM_HINTS | USABLE_BY_OWNER | USABLE_BY_PILOTS | USABLE_BY_ENEMIES )
	trident.UnsetUsable()
	
	vector foward = vehicle.GetForwardVector()

	vector tempOffset = <0 , 0, 20>
	vector offset = RotateVector(tempOffset, VectorToAngles(foward))
	player.SetOrigin(vehicle.GetOrigin() + offset)
	player.Hide()

	entity dummy = CreateEntity( "prop_dynamic" )
    dummy.SetValueForModelKey( player.GetModelName() )
    dummy.SetOrigin(vehicle.GetOrigin())
    dummy.SetAngles(vehicle.GetAngles())
	DispatchSpawn( dummy )
	dummy.SetParent(trident, "driver")
	thread HandleTridentAnims(trident, 8)
	vehicle.e.driverDummy = dummy
	thread HandlePlayerAnims(dummy, RandomInt(3))
	
	player.SetAngles(vehicle.GetAngles())
	player.SetParent(vehicle)

	thread DriveVehicle(player, vehicle, trident)
	thread HandleAngularVelocity(player, vehicle, trident)
	thread HoverVehicle(player, vehicle, trident)
	
	trident.SetOwner(player)

	player.SetThirdPersonShoulderModeOn() 	
	
	Remote_CallFunction_NonReplay( player, "SetupThirdPersonForVehicle", true)
	
	wait 2.0
	
	if(!IsValid(trident)) return
	
	trident.SetUsable()
	trident.SetUsableByGroup("pilot")
	trident.SetUsePrompts("%use% Exit Trident \n %speed% Boost", "%use% Exit Trident \n %speed% Boost")
	trident.AddUsableValue( USABLE_BY_OWNER )
	AddCallback_OnUseEntity(trident, OnUnuseCar)
}
void function OnUnuseCar(entity trident, entity user, int input)
{
	thread GetPlayerOutVehicle(user, trident.e.physicsCar, trident)
}

void function GetPlayerOutVehicle( entity player, entity vehicle, entity trident )
{
	// leaving car
	vector side = vehicle.GetRightVector()
	player.SetOrigin(vehicle.GetOrigin() + < 0, 0, 100>  - side * 75)
	player.SetThirdPersonShoulderModeOff() 	
	player.Show()
	player.ClearParent()
	Signal(vehicle, "StopDriving")
	RemoveCallback_OnUseEntity(trident, OnUnuseCar)
	thread HandleTridentAnims(trident, 7)
	trident.e.driver = null
	Remote_CallFunction_NonReplay( player, "SetupThirdPersonForVehicle", false)
	wait 2.0
	
	if(!IsValid(trident)) return
	AddCallback_OnUseEntity(trident, OnUseCar)
}

void function DriveVehicle(entity player, entity vehicle, entity trident)
{
	EndSignal( vehicle, "StopDriving")
	
	// // entity light = CreateEntity("prop_dynamic")
	// // light.kv.solid = 0
	// // light.SetValueForModelKey($"mdl/lamps/security_light_01_on.rmdl")
		// light.kv.rendercolor = "0 229 255"
	// // light.SetOrigin(trident.GetOrigin())
	// // light.SetAngles(trident.GetAngles())
	// // DispatchSpawn(light)
	// // light.SetParent(trident, "EXHAUST_REAR_L")
	// // light.SetModelScale(0.1)
	// entity exhaustFx = StartParticleEffectOnEntity_ReturnEntity( trident, GetParticleSystemIndex( $"P_ts_plasma_proj_MD" ), FX_PATTACH_ABSORIGIN_FOLLOW, trident.LookupAttachment( "EXHAUST_REAR_L" ) )
	// entity exhaustFx1 = StartParticleEffectOnEntity_ReturnEntity( trident, GetParticleSystemIndex( $"P_ts_plasma_proj_MD" ), FX_PATTACH_ABSORIGIN_FOLLOW, trident.LookupAttachment( "EXHAUST_REAR" ) )
	// entity exhaustFx2 = StartParticleEffectOnEntity_ReturnEntity( trident, GetParticleSystemIndex( $"P_ts_plasma_proj_MD" ), FX_PATTACH_ABSORIGIN_FOLLOW, trident.LookupAttachment( "EXHAUST_FRONT_L" ) )
	// entity exhaustFx3 = StartParticleEffectOnEntity_ReturnEntity( trident, GetParticleSystemIndex( $"P_ts_plasma_proj_MD" ), FX_PATTACH_ABSORIGIN_FOLLOW, trident.LookupAttachment( "EXHAUST_REAR_R" ) )
	// entity exhaustFx4 = StartParticleEffectOnEntity_ReturnEntity( trident, GetParticleSystemIndex( $"P_ts_plasma_proj_MD" ), FX_PATTACH_ABSORIGIN_FOLLOW, trident.LookupAttachment( "EXHAUST_FRONT_R" ) )
	// entity exhaustFx5 = StartParticleEffectOnEntity_ReturnEntity( trident, GetParticleSystemIndex( $"P_ts_plasma_proj_MD" ), FX_PATTACH_ABSORIGIN_FOLLOW, trident.LookupAttachment( "EXHAUST_FRONT" ) )
	// entity exhaustFx6 = StartParticleEffectOnEntity_ReturnEntity( trident, GetParticleSystemIndex( $"P_ts_plasma_proj_MD" ), FX_PATTACH_ABSORIGIN_FOLLOW, trident.LookupAttachment( "FX_AIRBRAKE_L" ) )
	// entity exhaustFx7 = StartParticleEffectOnEntity_ReturnEntity( trident, GetParticleSystemIndex( $"P_ts_plasma_proj_MD" ), FX_PATTACH_ABSORIGIN_FOLLOW, trident.LookupAttachment( "FX_AIRBRAKE_R" ) )
	// entity exhaustFx8 = StartParticleEffectOnEntity_ReturnEntity( trident, GetParticleSystemIndex( $"P_ts_plasma_proj_MD" ), FX_PATTACH_ABSORIGIN_FOLLOW, trident.LookupAttachment( "FX_BRAKE" ) )	
	
	
	OnThreadEnd( function() : ( vehicle, trident) {
		if ( IsValid( vehicle ) )
		{
			if(IsValid(vehicle.e.driverDummy))
				vehicle.e.driverDummy.Destroy()
			
			//todo: check ground before nulling movement
			vehicle.SetAngularVelocity( 0,0,0 )
			vehicle.SetVelocity( <0,0,0> )
			vehicle.StopPhysics()
		}
		
		if ( IsValid( trident ) )
		{
			trident.ClearBossPlayer()

			trident.SetUsable()
			trident.SetUsableByGroup("pilot")
			trident.SetUsePrompts("%use% Drive Trident", "%use% Drive Trident")
			trident.AddUsableValue( USABLE_CUSTOM_HINTS | USABLE_BY_OWNER | USABLE_BY_PILOTS | USABLE_BY_ENEMIES  )
		}
	})
	
	vector old_velocity = < 0, 0, 0>
	bool forwardInertia = true
	bool airborne = false
	bool hovering = false
	float absolute_old_velocity = 0

	vector normalDir
	vector dir
	vector pos
	vector maxs
	vector mins
	TraceResults result
	float dist
	float forward  = 0
	float backward = 0
	vector forwardSpeed
	vector newvel
	
	while(true)
	{
		if( !IsValid(player) || !IsValid(vehicle) ) break
		
		normalDir = -Normalize(vehicle.GetUpVector())
		dir = vehicle.GetForwardVector()
		vehicle.e.isInAirborne = false
		
		pos = vehicle.GetOrigin()

		result = TraceHull( pos, pos +  150 * normalDir, GetBoundsMin( HULL_HUMAN ), GetBoundsMax( HULL_HUMAN ), [vehicle], TRACE_MASK_NPCWORLDSTATIC, TRACE_COLLISION_GROUP_PLAYER )
		//DebugDrawAxis( pos, -normalDir, 1, 150)
		
		vehicle.e.hoverTrace = result
		vector normal = result.surfaceNormal
		dist = Length(result.endPos - pos)
		
		if (dist > 100)
		{
			printt("airborne")
			vehicle.e.isInAirborne = true
	
		} else 
		{
			vehicle.e.isInAirborne = false
		}

		// RESET
		// if ( player.IsInputCommandHeld( IN_SPEED ) ) 
		// {

			// ResetPos( vehicle, true )
		// }
		
		// BOOST
		if(player.IsInputCommandHeld( IN_SPEED ))
		{
			if(vehicle.e.canBoost){
				thread Boost(vehicle, player)
			}
		}

		forward  = 0
		backward = 0

		// AxisForward
		switch(player.GetInputAxisForward())
		{
			case 1:
				if(player.p.lastForwardInput != player.GetInputAxisForward())
					thread HandleTridentAnims(trident, 1)
				trident.Anim_Stop()
				forward = 800
				
				if (Length(old_velocity) > forward)
				{
					forward = Length(old_velocity) * 0.9
					if (forward < 800)
						forward = 800
				}

				if ( Length(old_velocity) < forward)
				{
					forward = Length(old_velocity) + 50
				}

				if (vehicle.e.isBoosting){
					forward = 1800
				} 

				forwardInertia = true			
			break
			
			case -1:
				if(player.p.lastForwardInput != player.GetInputAxisForward())
					thread HandleTridentAnims(trident, 3)
				trident.Anim_Stop()
				backward = -300

				if (forwardInertia)
				{
					// speed damping instead of going backward
					forward = Length(old_velocity) - 100
					if ( forward < 0){
						forward = 0
						forwardInertia = false
					}
				} else {
					if ( -Length(old_velocity) > backward)
					{
						backward = -Length(old_velocity) - 50
						forwardInertia = false
					}
				}
				forwardInertia = false			
			break
		}
		
		forwardSpeed = dir * (forward + backward)
		vehicle.e.forwardSpeed = forwardSpeed
		
		// inertia
		if(forward == 0 && backward == 0)
        {
        	if (forwardInertia)
        		forwardSpeed = old_velocity * 0.8
        	else 
        		forwardSpeed = old_velocity * 0.5
        }

        if(airborne) {
        	forwardSpeed = old_velocity * 0.99
        }

		old_velocity = forwardSpeed

		if(!airborne)
		{
			vehicle.SetVelocity(forwardSpeed)
		} else {
			old_velocity = vehicle.GetVelocity()
		}

		//Trident strafe
		if( player.GetInputAxisRight() != 0 && player.GetInputAxisForward() == 0 && !airborne && Length(forwardSpeed) < 100)
		{
			vehicle.SetVelocity(vehicle.GetVelocity()+AnglesToRight(vehicle.GetAngles())*signum(player.GetInputAxisRight())*150)
			trident.Anim_Stop()
			switch(player.GetInputAxisRight() )
			{
				case 1:
				if(player.p.lastRightInput != player.GetInputAxisRight())
					thread HandleTridentAnims(trident, 12)
				break
				case -1:
				if(player.p.lastRightInput != player.GetInputAxisRight())
					thread HandleTridentAnims(trident, 11)
				break
			}
		}

		player.p.lastRightInput = player.GetInputAxisRight()
		player.p.lastForwardInput = player.GetInputAxisForward()
		
		WaitFrame()
	}
}

void function HandleAngularVelocity(entity player, entity vehicle, entity trident)
{
	EndSignal( vehicle, "StopDriving")

	OnThreadEnd( function() : ( vehicle, trident) {
		if ( IsValid( vehicle ) )
		{
			vehicle.SetAngularVelocity( 0,0,0 )
		}

	})
	
	vector old_velocity = < 0, 0, 0>
	bool forwardInertia = true
	vector normalDir
	vector dir
	float forward  = 0
	float backward = 0
	vector forwardSpeed
	
	while(true)
	{
		if( !IsValid(player) || !IsValid(vehicle) ) break
		
		forwardSpeed = vehicle.e.forwardSpeed
		
		vector rotAng = < 0, 50, 0 >

		if(vehicle.e.isInAirborne){
			rotAng = < 0, 35, 0>
		}
		
		//AxisRight
		vector angVelocity = < 0, 0, 0>
		
		if(player.GetInputAxisRight() != 0 && Length(forwardSpeed) >= 100)
			angVelocity = -signum(player.GetInputAxisRight()) * rotAng
		
		if(backward == 0 && Length(forwardSpeed) >= 100 || backward == 0 && Length(forwardSpeed) >= 100 ) 
        {
        	angVelocity.y += 200 * -AnglesToRight( vehicle.GetAngles() - player.CameraAngles() ).x //holy fuck. Colombia
        }
		
		if(vehicle.e.isInAirborne)
		{
			angVelocity += < signum(player.GetInputAxisForward()) * 20, angVelocity.y, signum(player.GetInputAxisRight())*20 > 
		}
		
		if(backward < 0)
			angVelocity = -angVelocity

		vehicle.SetAngularVelocity( angVelocity.x, angVelocity.y , angVelocity.z ) //magnific
		
		WaitFrame()
	}	
}

void function HoverVehicle(entity player, entity vehicle, entity trident)
{
	EndSignal( vehicle, "StopDriving")
	vector pos
	vector maxs
	vector mins
	TraceResults result
	float dist
	vector vel
	
	float startTime = Time()
	float timePassed
	float height
	vector normal
	bool resetTime = false
	float dt = 0.01666667 // old behavior
	vector velocity
	float strength
	
	while(true)
	{
		if( !IsValid(player) || !IsValid(vehicle) ) break
		
		if(vehicle.e.isInAirborne) 
		{
			WaitFrame()
			continue
		}
		
		pos = vehicle.GetOrigin()
		result = vehicle.e.hoverTrace		
		dist = Length(result.endPos - pos)
		velocity = vehicle.GetVelocity()
		
		// height = GraphCapped( Time(), LERP_IN_FLOAT, 1, GraphCapped( timePassed, 0, 2, 150, TRIDENT_HOVER_HEIGHT ), TRIDENT_HOVER_HEIGHT )
		normal = result.surfaceNormal
		
		if(player.GetInputAxisForward() == 0 && player.GetInputAxisRight() == 0)
			resetTime = true
		
		timePassed = Time() - startTime
		
		if (dist <= TRIDENT_HOVER_HEIGHT && player.GetInputAxisForward() != 0 || dist <= TRIDENT_HOVER_HEIGHT && player.GetInputAxisRight() != 0)
		{
			if(resetTime)
			{
				startTime = Time()
				resetTime = false
			}
			height = GraphCapped( timePassed, LERP_IN_FLOAT, 2, dist, TRIDENT_HOVER_HEIGHT )
			// strength = GraphCapped( timePassed, 0.0, 1, dist, TRIDENT_HOVER_HEIGHT )
			
			printt("DIST: " + dist + " " + " | HeightValue: " + height + " | Strenght value " + strength)
	
			//float distFromCover = Distance( testPos, result.endPos )
			
	
			velocity += Normalize(normal) * height
			
		}
		// else if (dist <= TRIDENT_HOVER_HEIGHT && player.GetInputAxisForward() != 0 || dist <= TRIDENT_HOVER_HEIGHT && player.GetInputAxisRight() != 0)
		// {
			// if(resetTime)
			// {
				// startTime = Time()
				// resetTime = false
			// }
			// height = GraphCapped( timePassed, LERP_IN_FLOAT, 2, dist, TRIDENT_HOVER_HEIGHT )
			// // strength = GraphCapped( timePassed, 0.0, 1, dist, TRIDENT_HOVER_HEIGHT )
			
			// printt("DIST: " + dist + " " + " | HeightValue: " + height + " | Strenght value " + strength)
	
			// //float distFromCover = Distance( testPos, result.endPos )
			
	
			// velocity += Normalize(normal) * height
		// }		
		// else (dist <= TRIDENT_HOVER_HEIGHT && player.GetInputAxisForward() != 0 || dist <= TRIDENT_HOVER_HEIGHT && player.GetInputAxisRight() != 0)
		// {
			// if(resetTime)
			// {
				// startTime = Time()
				// resetTime = false
			// }
			// height = GraphCapped( timePassed, LERP_IN_FLOAT, 2, 100-dist, TRIDENT_HOVER_HEIGHT )
			// printt("DIST: " + dist + " " + " | HeightValue: " + height)
			// velocity += Normalize(normal) * height
		// }
		
		if(dist > TRIDENT_HOVER_HEIGHT && player.GetInputAxisForward() != 0 && !vehicle.e.isInAirborne || dist > TRIDENT_HOVER_HEIGHT && player.GetInputAxisRight() != 0 && !vehicle.e.isInAirborne)
		{
			velocity -= Normalize(normal)
		}
		
		vehicle.SetVelocity( velocity )
		
		WaitFrame()
	}
}

// float function GetHoverStrength( entity ent, vector testPos, vector cylinderBottom, vector cylinderTop, vector fanDirection )
// {
	// vector pointAlongFan = GetClosestPointOnLineSegment( cylinderBottom, cylinderTop, testPos )
	// vector vecFromFanCenter = testPos - pointAlongFan
	// vector traceEnd = cylinderBottom + vecFromFanCenter

	// // Trace from the entity towards the fan along the fan axis to see if we are getting blocked
	// TraceResults result = TraceLine( testPos, traceEnd, ent, TRACE_MASK_NPCSOLID, TRACE_COLLISION_GROUP_NONE )

	// float distFromCover = Distance( testPos, result.endPos )
	// float strength = GraphCapped( distFromCover, 256, 1024, 0.0, 1.0 )
	// if ( result.fraction == 1.0 )
		// strength = 1.0

		// printt( "strength:", strength )
		// printt( "fraction:", result.fraction )
		// printt( "dist from fan:", Distance( testPos, cylinderBottom ) )
		// printt( "distFromCover:", distFromCover )

	// Assert( strength >= 0.0 && strength <= 1.0 )
	// return strength
// }

void function HandleTridentAnims(entity trident, int index)
{

	string animtoplay
	
	switch(index)
	{
		case 1:
			animtoplay = "animseq/vehicle/olympus_hovercraft/olympus_hovercraft/hovercraft_activate_chase.rseq"
		break
		
		case 2:
			animtoplay = "animseq/vehicle/olympus_hovercraft/olympus_hovercraft/hovercraft_activate_hover.rseq"
		break
		
		case 3:
			animtoplay = "animseq/vehicle/olympus_hovercraft/olympus_hovercraft/hovercraft_breaking_idle.rseq"
		break
		
		case 4:
			animtoplay = "animseq/vehicle/olympus_hovercraft/olympus_hovercraft/hovercraft_chase_idle.rseq"
		break
		
		case 5:
			animtoplay = "animseq/vehicle/olympus_hovercraft/olympus_hovercraft/hovercraft_damage_large.rseq"
		break
		
		case 6:
			animtoplay = "animseq/vehicle/olympus_hovercraft/olympus_hovercraft/hovercraft_damage_small.rseq"
		break
		
		case 7:
			animtoplay = "animseq/vehicle/olympus_hovercraft/olympus_hovercraft/hovercraft_deactivate.rseq"
		break
		
		case 8:
			animtoplay = "animseq/vehicle/olympus_hovercraft/olympus_hovercraft/hovercraft_grounded_idle.rseq"
		break
		
		case 9:
			animtoplay = "animseq/vehicle/olympus_hovercraft/olympus_hovercraft/hovercraft_hover_idle.rseq"
		break
		
		case 10:
			animtoplay = "animseq/vehicle/olympus_hovercraft/olympus_hovercraft/hovercraft_Rside_mount_across.rseq"
		break
		
		case 11:
			animtoplay = "animseq/vehicle/olympus_hovercraft/olympus_hovercraft/hovercraft_strafe_Left.rseq"
		break
		
		case 12:
			animtoplay = "animseq/vehicle/olympus_hovercraft/olympus_hovercraft/hovercraft_strafe_Right.rseq"
		break
		
		case 13:
			animtoplay = "animseq/vehicle/olympus_hovercraft/olympus_hovercraft/hovercraft_turn_Left.rseq"
		break
		
		case 14:
			animtoplay = "animseq/vehicle/olympus_hovercraft/olympus_hovercraft/hovercraft_turn_Right.rseq"
		break
	}
	
	if(trident.e.LastTridentAnim == animtoplay) return
		
	Signal( trident, "NewTridentAnim" )
	EndSignal( trident, "NewTridentAnim" )
	EndSignal( trident, "StopDriving")
	
	OnThreadEnd( function() : ( trident ) {
		if ( IsValid( trident ) )
		{
			if(IsValid(trident.e.driver))
				thread HandleTridentAnims(trident, 9)
			else
				thread HandleTridentAnims(trident, 8)
		}
	})
	
	trident.Anim_NonScriptedPlay(animtoplay)
	trident.e.LastTridentAnim = animtoplay
	float maxTime = Time() + trident.GetSequenceDuration(animtoplay)
	
	//printt(trident.GetSequenceDuration(animtoplay))
	
	if(index == 4) //chase idle
	{
		maxTime = Time() + trident.GetSequenceDuration(animtoplay) - 1.5
	}
	
	if(maxTime <= 0) return
	
	while( Time() < maxTime )
		WaitFrame()
	
	trident.e.LastTridentAnim = ""
}

void function HandlePlayerAnims(entity dummyPlayer, int index)
{
	string animtoplay
	
	switch(index)
	{
		case 1:
			animtoplay = "ACT_MP_MENU_LOBBY_SELECT_IDLE"
		break
		
		case 2:
			animtoplay = "ACT_MP_MENU_LOBBY_SELECT_IDLE"
		break
		
		case 3:
			animtoplay = "ACT_MP_MENU_LOBBY_SELECT_IDLE"
		break
	}

	EndSignal( dummyPlayer, "OnDestroy")
	
	OnThreadEnd( function() : ( dummyPlayer ) {
		if ( IsValid( dummyPlayer ) )
		{
			dummyPlayer.Anim_Stop()
			thread HandlePlayerAnims(dummyPlayer, RandomInt(3))
		}
	})

	float maxTime = 1
	bool animExists = dummyPlayer.LookupSequence( animtoplay ) != -1
		if ( animExists )
		{
			dummyPlayer.Anim_Play(animtoplay)
			maxTime = Time() + dummyPlayer.GetSequenceDuration(animtoplay)
		}
	
	while( Time() < maxTime )
		WaitFrame()
}

void function Boost(entity vehicle, entity player)
{
	if(!IsValid(vehicle)) return
	vehicle.e.canBoost = false
	vehicle.e.isBoosting = true
	Remote_CallFunction_NonReplay( player, "TridentBoost_Visuals" )
	wait 1.5
	if(!IsValid(vehicle)) return
	vehicle.e.isBoosting = false
	wait 8.0
	if(!IsValid(vehicle)) return
	vehicle.e.canBoost = true
}

#endif

#if CLIENT
void function SetupThirdPersonForVehicle(bool enable)
{
	if(enable)
	{
		SetConVarFloat( "c_thirdpersonshoulderheight", 15.0 )
		SetConVarFloat( "c_thirdpersonshoulderoffset", 0.0 )
		SetConVarFloat( "c_thirdpersonshoulderaimdist", 200.0 )
	}
	else
	{
		SetConVarFloat("c_thirdpersonshoulderheight", 30)
		SetConVarFloat("c_thirdpersonshoulderoffset", 20)
		SetConVarFloat("c_thirdpersonshoulderaimdist", 100)
	}
}

void function TridentBoost_Visuals()
{
	entity player = GetLocalViewPlayer()
	
	thread function() : (player)
	{
		if( !IsValid(player) || !IsValid( player.GetCockpit() )) return

		EndSignal( player, "OnDeath" )
		
		float endTime = Time() + 2
		int fxHandle
		
		if ( IsValid( player.GetCockpit() ) )
		{
			fxHandle = StartParticleEffectOnEntity( player.GetCockpit(), GetParticleSystemIndex( SPRINT_FP ), FX_PATTACH_ABSORIGIN_FOLLOW, -1 )
			EffectSetIsWithCockpit( fxHandle, true )
		}

		OnThreadEnd(
		function() : (fxHandle, player)
		{
			if(IsValid(player))
				player.SetFOVScale( 1, 0.1 )
			if ( fxHandle > -1 )
				EffectStop( fxHandle, false, true )
		})

		while( Time() <= endTime && IsValid(player) )
		{
			player.SetFOVScale( 1.15, 0.1 )
			WaitFrame()
		}
	}()
}
#endif